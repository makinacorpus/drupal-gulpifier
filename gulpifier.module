<?php

/**
 * Implements hook_js_alter().
 */
function gulpifier_js_alter(&$js) {
  global $theme;
  $theme_path = drupal_get_path('theme', $theme);

  // Only work if theme is gulpifier-enabled
  if (!theme_get_setting('gulpifier_enabled')) {
    return;
  }

  // We build our whitelist, the whitelist is a list of files that won't be
  // processed by our logic.
  $whitelist = gulpifier_get_whitelist($theme, 'js');

  // Get the bundle script path.
  $script_path = theme_get_setting('gulpifier_js_bundle_path') ?: $theme_path . '/dist/script.min.js';

  // First part of the proces, discover.
  if (theme_get_setting('gulpifier_discover')) {
    $map_path = theme_get_setting('gulpifier_map_path') ?: $theme_path . '/js/map.json';

    gulpifier_discover_js($js, $map_path, $script_path, $whitelist);
  }

  // Force every script to be in the same scope. In that way, we could render
  // them all together anywhere we want.
  foreach ($js as $name => $settings) {
    $js[$name]['scope'] = 'header';
  }

  // A single JS file means we work in a production environment, so include only
  // our single JS file, generated by gulp, and those from the whitelist.
  if (theme_get_setting('gulpifier_single_js')) {
    foreach ($js as $name => $settings) {
      // Exclude all files except for our own, and Drupal.settings
      if ($name != 'settings' && $name != $script_path && !in_array($name, $whitelist, TRUE)) {
        unset($js[$name]);
      }
      else {
        // For the rest, use the same group, to have a single bundle
        $js[$name]['group'] = JS_DEFAULT;
      }
    }

    // Change its group and weight to be the first one included.
    // In that way, all other scripts whitelist don't have to take care about
    // group and weight regarding to this global aggregate scripts which may
    // contains library.
    $js[$script_path]['group'] = JS_LIBRARY;
    $js[$script_path]['preprocess'] = FALSE;
    $js[$script_path]['weight'] = -900;
  }
  else {
    // Remove our processed file on all requests.
    if (isset($js[$script_path])) {
      unset($js[$script_path]);
    }
  }
}

/**
 * Get cleaned whitelist
 *
 * @param string $theme Theme name to get the whitelist for
 * @param string $type Whitelist type 'js' or 'css'
 * @return array
 */
function gulpifier_get_whitelist($theme, $type) {
  $whitelist = &drupal_static(__FUNCTION__, NULL);
  $whitelist = (array) theme_get_setting('gulpifier_whitelist', $theme);

  // Transform the module_name:path notation
  foreach ($whitelist as &$file) {
    if (FALSE !== strstr($file, ':')) {
      list($module, $path) = explode(':', $file, 1);
      $file = drupal_get_path('module', $module) . $path;
    }
  }

  return isset($whitelist[$type]) ? $whitelist[$type] : array();
}

/**
 * Populate a map.json with the JS files of the current page
 *
 * During discovery, we will try to populate the map.json file
 * with JS files that are included on each page of the site.
 *
 * @param $js
 *  The big JS array of the current page provided by Drupal
 * @param $map_path
 *  The JSON map file path
 * @param $script_path
 *  The minified JS file path
 * @param $whitelist
 *  The JS whitelist from the theme .info file
 */
function gulpifier_discover_js($js, $map_path, $script_path, $whitelist) {
  // Load previous list
  $contents = file_get_contents($map_path);
  $list = FALSE;
  if ($contents !== FALSE) {
    // We have a list, parse it
    $list = drupal_json_decode($contents);
  }
  // else reading file failed, and we won't update it programmatically, but
  // we will still remove our single file

  foreach ($js as $name => $settings) {
    // Prevent some files from being processed.
    if ($name == $script_path) {
      // We won't need our single file here
      unset($js[$name]);
      continue;
    }
    elseif ('settings' === $name) {
      continue; // Ignore Drupal.settings.
    }
    elseif (FALSE !== strstr($name, 'languages/')) {
      continue; // Ignore Drupal.t sources.
    }
    elseif ('external' === $settings['type']) {
      continue; // Ignore external code.
    }
    elseif ('inline' === $settings['type']) {
      continue; // Ignore inline code.
    }

    // If we have a list, update it
    if ($list !== FALSE && !in_array($name, $whitelist, TRUE)) {
      // TRUE will add it, FALSE will remove it, edit the map.json file
      // directly if you need to exclude a file
      $list[$name] = isset($list[$name]) ? $list[$name] : TRUE;
    }
  }
  // Udpate map.json
  if ($list !== FALSE && defined('JSON_PRETTY_PRINT')) {
    $json = json_encode($list, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);
    if ($contents !== $json) {
      file_put_contents($map_path, $json);
    }
  }
}

/**
 * Implements hook_css_alter().
 */
function gulpifier_css_alter(&$css) {
  global $theme;
  $theme_path = drupal_get_path('theme', $theme);

  // Only work on the front-end theme
  if (!theme_get_setting('gulpifier_enabled')) {
    return;
  }

  // We build our whitelist, the whitelist is a list of files that won't be
  // processed by our logic.
  $whitelist = gulpifier_get_whitelist($theme, 'css');

  // Get the bundle style path.
  $style_path = theme_get_setting('gulpifier_css_bundle_path') ?: $theme_path . '/dist/style.min.css';

  // alouette_single_css means we work in a production environment, so we analyse the
  // only need our single CSS file
  if (theme_get_setting('gulpifier_single_css')) {
    // Here we do a whitelist only on our file and inline CSS
    foreach ($css as $name => $settings) {
      if ($style_path === $name) {
        $css[$name]['preprocess'] = FALSE;
        continue; // This is our file!
      }

      if ($settings['type'] == 'inline') {
        // This will disable @import commands, better for requests
        $css[$name]['preprocess'] = FALSE;
      }
      elseif ('external' !== $settings['type'] && !in_array($name, $whitelist, TRUE)) {
        unset($css[$name]);
      }
      else {
        // For the rest, use the same group, to have a single bundle
        $css[$name]['group'] = CSS_DEFAULT;
      }
    }
  }
  else {
    // Remove our processed file on all requests.
    if (isset($css[$style_path])) {
      unset($css[$style_path]);
    }
  }
}

/**
 * Implements hook_process_html().
 */
function gulpifier_process_html(&$vars) {
  if (theme_get_setting('gulpifier_nocachebuster') && !stristr($_GET['q'], 'flush-cache')) {
    $vars['styles'] = preg_replace('@\.css\?.*"@U', '.css"', $vars['styles']);
    $vars['scripts'] = preg_replace('@\.js\?.*"@U', '.js"', $vars['scripts']);
  }
}

/**
 * Implements hook_form_system_theme_settings_alter().
 */
function gulpifier_form_system_theme_settings_alter(&$form, &$form_state) {
  // Wrap global setting fieldsets in vertical tabs.
  $form['general'] = array(
    '#type'   => 'vertical_tabs',
    '#prefix' => '<h2>' . t('Override Global Settings') . '</h2>',
    '#weight' => -9,
  );
  $form['theme_settings']['#group'] = 'general';
  $form['logo']['#group'] = 'general';
  $form['favicon']['#group'] = 'general';

  // Do not add gulpifier specific settings to global settings.
  if (empty($form_state['build_info']['args'][0])) {
    unset($form['general']['#prefix']);
    return;
  }

  $theme_path = drupal_get_path('theme', $form_state['build_info']['args'][0]);

  $form['gulpifier'] = array(
    '#weight' => -10,
    '#prefix' => '<h2>' . t('Gulpifier settings') . '</h2>',
  );
  $form['gulpifier']['js'] = array(
    '#type'  => 'fieldset',
    '#title' => t('Javascript'),
  );
  $form['gulpifier']['js']['gulpifier_discover'] = array(
    '#type'          => 'checkbox',
    '#title'         => t("Enable JS discovery"),
    '#description'   => t("In this mode, a JSON map of the JS files used will be built upon each page request. You can manually edit it to exclude some files, or reorder the files between them."),
    '#default_value' => theme_get_setting('gulpifier_discover'),
  );
  $form['gulpifier']['js']['gulpifier_map_path'] = array(
    '#type'          => 'textfield',
    '#title'         => t("Path to the map.json file"),
    '#description'   => t("The path to the JSON map. It is advised to track it within your VCS, most probably in the theme."),
    '#default_value' => theme_get_setting('gulpifier_map_path') ?: $theme_path . '/js/map.json',
  );
  $form['#validate'] = array('gulpifier_form_map_path_validate');
  $form['gulpifier']['js']['gulpifier_single_js'] = array(
    '#type'          => 'checkbox',
    '#title'         => t("Enable single JS file (production mode)"),
    '#description'   => t("In this mode, all JS files that are not in the whitelist are removed, and replaced with the one generated by Gulp."),
    '#default_value' => theme_get_setting('gulpifier_single_js'),
  );
  $form['gulpifier']['js']['gulpifier_whitelist'] = array(
    '#type'          => 'checkbox',
    '#title'         => t("Enable single JS file (production mode)"),
    '#description'   => t("In this mode, all JS files that are not in the whitelist are removed, and replaced with the one generated by Gulp."),
    '#default_value' => theme_get_setting('gulpifier_single_js'),
  );

  $form['gulpifier']['css'] = array(
    '#type'  => 'fieldset',
    '#title' => t('CSS'),
  );
  $form['gulpifier']['css']['gulpifier_single_css'] = array(
    '#type'          => 'checkbox',
    '#title'         => t("Enable single CSS file (production mode)"),
    '#description'   => t("In this mode, all CSS files that are not in the whitelist are removed, and replaced with the one generated by Gulp."),
    '#default_value' => theme_get_setting('gulpifier_single_css'),
  );
}

/**
 * Validate JSON map path
 *
 * @param $element
 * @param $form_state
 * @param $form
 */
function gulpifier_form_map_path_validate($form, &$form_state) {
  $values = $form_state['values'];
  if ($values['gulpifier_discover'] && empty($values['gulpifier_map_path'])) {
    form_set_error('gulpifier_map_path', t('The path to the JSON map is required if discovery is enabled.'));
  }
  else {
    if ($values['gulpifier_discover'] && !empty($values['gulpifier_map_path']) && !file_exists($values['gulpifier_map_path'])) {
      form_set_error('gulpifier_map_path', t('The path to the JSON map must point to a existing file.'));
    }
  }
}
