<?php

/**
 * Implements hook_js_alter().
 */
function gulpifier_js_alter(&$js) {
  global $theme;
  $theme_path = drupal_get_path('theme', $theme);

  // Only work if theme is gulpifier-enabled
  if (!theme_get_setting('gulpifier_enabled')) {
    return;
  }

  // We build our whitelist, the whitelist is a list of files that won't be
  // processed by our logic.
  $whitelist = gulpifier_get_whitelist($theme, 'js');

  // We build our blacklist, the blacklist is a list of files that will never
  // appear either when our bundle is activated, nor when it isn't.
  $blacklist = gulpifier_get_js_blacklist($theme);
  foreach ($blacklist as $file) {
    if (isset($js[$file])) {
      unset($js[$file]);
    }
  }

  // Get the bundle script path.
  $script_path = theme_get_setting('gulpifier_js_bundle_path') ?: $theme_path . '/dist/script.min.js';

  // First part of the process, discover.
  if (theme_get_setting('gulpifier_discover') && !variable_get('gulpifier_discovery_killswitch', FALSE)) {
    $map_path = DRUPAL_ROOT . '/';
    $map_path .= theme_get_setting('gulpifier_map_path') ?: $theme_path . '/js/map.json';

    gulpifier_discover_js($js, $map_path, $script_path, $whitelist);
  }

  // Force every script to be in the same scope. In that way, we could render
  // them all together anywhere we want, with better aggregation.
  if (theme_get_setting('gulpifier_js_same_scope') || theme_get_setting('gulpifier_js_same_group')) {
    foreach ($js as $name => $settings) {
      if (theme_get_setting('gulpifier_js_same_scope')) {
        $js[$name]['scope'] = 'header';
      }
      if (theme_get_setting('gulpifier_js_same_group')) {
        $js[$name]['group'] = JS_DEFAULT;
      }
    }
  }

  // A single JS file means include only our single JS file, generated by gulp,
  // and those from the whitelist.
  if (theme_get_setting('gulpifier_single_js')) {
    foreach ($js as $name => $settings) {
      // Exclude all files except for our own, and Drupal.settings
      if (_gulpifier_match($name, $settings, $script_path) && !in_array($name, $whitelist, TRUE)) {
        unset($js[$name]);
      }
    }

    // Change its group and weight to be the first one included.
    // In that way, all other scripts whitelist don't have to take care about
    // group and weight regarding to this global aggregate scripts which may
    // contains library.
    $js[$script_path]['group'] = JS_LIBRARY;
    $js[$script_path]['preprocess'] = FALSE;
    $js[$script_path]['weight'] = -900;
  }
  else {
    // Remove our processed file on all requests.
    if (isset($js[$script_path])) {
      unset($js[$script_path]);
    }
  }
}

/**
 * Get cleaned whitelist
 *
 * @param string $theme Theme name to get the whitelist for
 * @param string $type Whitelist type 'js' or 'css'
 * @return array
 */
function gulpifier_get_whitelist($theme, $type) {
  $whitelist = &drupal_static(__FUNCTION__, NULL);
  $whitelist = (array) theme_get_setting('gulpifier_whitelist', $theme);

  // Transform the module_name:path notation
  if (isset($whitelist[$type]) && is_array($whitelist[$type])) {
    foreach ($whitelist[$type] as $index => $file) {
      if (FALSE !== strstr($file, ':')) {
        list($module, $path) = explode(':', $file);
        $prefix = null;
        if (module_exists($module)) {
          $prefix = drupal_get_path('module', $module);
        } else if ($module === $GLOBALS['theme']) {
          $prefix = path_to_theme();
        }
        if ($prefix) {
          $whitelist[$type][$index] = $prefix . '/' . $path;
        }
      }
    }
  }

  return isset($whitelist[$type]) ? $whitelist[$type] : array();
}

/**
 * Get cleaned JS blacklist
 *
 * @param string $theme Theme name to get the blacklist for
 * @return array An array a file paths to exclude
 */
function gulpifier_get_js_blacklist($theme) {
  $whitelist = &drupal_static(__FUNCTION__, NULL);
  $whitelist = (array) theme_get_setting('gulpifier_js_blacklist', $theme);

  // Transform the module_name:path notation
  if (isset($whitelist) && is_array($whitelist)) {
    foreach ($whitelist as $index => $file) {
      if (FALSE !== strstr($file, ':')) {
        list($module, $path) = explode(':', $file);
        $prefix = null;
        if (module_exists($module)) {
          $prefix = drupal_get_path('module', $module);
        } else if ($module === $GLOBALS['theme']) {
          $prefix = path_to_theme();
        }
        if ($prefix) {
          $whitelist[$index] = $prefix . '/' . $path;
        }
      }
    }
  }

  return isset($whitelist) ? $whitelist : array();
}

/**
 * Populate a map.json with the JS files of the current page
 *
 * During discovery, we will try to populate the map.json file
 * with JS files that are included on each page of the site.
 *
 * @param $js
 *  The big JS array of the current page provided by Drupal
 * @param $map_path
 *  The JSON map file path
 * @param $script_path
 *  The minified JS file path
 * @param $whitelist
 *  The JS whitelist from the theme .info file
 */
function gulpifier_discover_js($js, $map_path, $script_path, $whitelist) {
  // Load previous list
  $contents = file_get_contents($map_path);
  $list = FALSE;
  if ($contents !== FALSE) {
    // We have a list, parse it
    $list = drupal_json_decode($contents);
  }
  // else reading file failed, and we won't update it programmatically, but
  // we will still remove our single file

  foreach ($js as $name => $settings) {
    // If we have a list, update it
    if (_gulpifier_match($name, $settings, $script_path) && $list !== FALSE && !in_array($name, $whitelist, TRUE)) {
      // TRUE will add it, FALSE will remove it, edit the map.json file
      // directly if you need to exclude a file
      $list[$name] = isset($list[$name]) ? $list[$name] : TRUE;
    }
  }
  // Udpate map.json
  if ($list !== FALSE && defined('JSON_PRETTY_PRINT')) {
    $json = json_encode($list, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);
    if ($contents !== $json) {
      file_put_contents($map_path, $json);
    }
  }
}

/**
 * Implements hook_css_alter().
 */
function gulpifier_css_alter(&$css) {
  global $theme;
  $theme_path = drupal_get_path('theme', $theme);

  // Only work on the front-end theme
  if (!theme_get_setting('gulpifier_enabled')) {
    return;
  }

  // We build our whitelist, the whitelist is a list of files that won't be
  // processed by our logic.
  $whitelist = gulpifier_get_whitelist($theme, 'css');

  // Get the bundle style path.
  $style_path = theme_get_setting('gulpifier_css_bundle_path') ?: $theme_path . '/dist/style.min.css';

  // Force every script to be in the same scope. In that way, we could render
  // them all together anywhere we want, with better aggregation.
  if (theme_get_setting('gulpifier_css_same_group')) {
    foreach ($css as $name => $settings) {
      $css[$name]['group'] = CSS_DEFAULT;
    }
  }

  // alouette_single_css means we work in a production environment, so we analyse the
  // only need our single CSS file
  if (theme_get_setting('gulpifier_single_css')) {
    // Here we do a whitelist only on our file and inline CSS
    foreach ($css as $name => $settings) {
      if ($style_path === $name) {
        // This is our file!
        $css[$name]['preprocess'] = FALSE;
      }
      elseif ($settings['type'] == 'inline') {
        // This will disable @import commands, thus fewer requests.
        $css[$name]['preprocess'] = FALSE;
      }
      elseif ('external' !== $settings['type'] && !in_array($name, $whitelist, TRUE)) {
        // Exclude all others
        unset($css[$name]);
      }
    }
  }
  else {
    // Remove our processed file on all requests.
    if (isset($css[$style_path])) {
      unset($css[$style_path]);
    }
  }
}

/**
 * Implements hook_process_html().
 */
function gulpifier_process_html(&$vars) {
  if (theme_get_setting('gulpifier_nocachebuster') && !stristr($_GET['q'], 'flush-cache')) {
    $vars['styles'] = preg_replace('@\.css\?.*"@U', '.css"', $vars['styles']);
    $vars['scripts'] = preg_replace('@\.js\?.*"@U', '.js"', $vars['scripts']);
  }
}

/**
 * Implements hook_form_system_theme_settings_alter().
 */
function gulpifier_form_system_theme_settings_alter(&$form, &$form_state) {
  // Wrap global setting fieldsets in vertical tabs.
  $form['general'] = array(
    '#type'   => 'vertical_tabs',
    '#prefix' => '<h2>' . t('Override Global Settings') . '</h2>',
    '#weight' => -9,
  );
  $form['theme_settings']['#group'] = 'general';
  $form['logo']['#group'] = 'general';
  $form['favicon']['#group'] = 'general';

  // Do not add gulpifier specific settings to global settings.
  if (empty($form_state['build_info']['args'][0])) {
    unset($form['general']['#prefix']);
    return;
  }

  $theme_name = $form_state['build_info']['args'][0];
  $theme_path = drupal_get_path('theme', $theme_name);

  $themes = list_themes();
  $theme_object = $themes[$theme_name];

  $form['gulpifier'] = array(
    '#weight' => -10,
    '#prefix' => '<h2>' . t('Gulpifier settings') . '</h2><p>Disabled options means they are set in the theme .info file.</p>',
  );
  $form['gulpifier']['gulpifier_enabled'] = array(
    '#type'          => 'checkbox',
    '#title'         => t("Enable Gulpifier for this theme"),
    '#default_value' => theme_get_setting('gulpifier_enabled', $theme_name),
    '#disabled'      => isset($theme_object->info['settings']['gulpifier_enabled']),
  );
  $form['gulpifier']['js'] = array(
    '#type'  => 'fieldset',
    '#title' => t('Javascript'),
  );
  $form['gulpifier']['js']['gulpifier_discover'] = array(
    '#type'          => 'checkbox',
    '#title'         => t("Enable JS discovery"),
    '#description'   => t("In this mode, a JSON map of the JS files used will be built upon each page request. You can manually edit it to exclude some files, or reorder the files between them."),
    '#default_value' => theme_get_setting('gulpifier_discover', $theme_name),
    '#disabled'      => isset($theme_object->info['settings']['gulpifier_discover']),
  );
  $form['gulpifier']['js']['gulpifier_map_path'] = array(
    '#type'          => 'textfield',
    '#title'         => t("Path to the map.json file"),
    '#description'   => t("The path to the JSON map. It is advised to track it within your VCS, most probably in the theme."),
    '#default_value' => theme_get_setting('gulpifier_map_path', $theme_name) ?: $theme_path . '/js/map.json',
    '#disabled'      => isset($theme_object->info['settings']['gulpifier_map_path']),
  );
  $form['#validate'][] = 'gulpifier_form_map_path_validate';
  $form['gulpifier']['js']['gulpifier_single_js'] = array(
    '#type'          => 'checkbox',
    '#title'         => t("Enable single JS file (production mode)"),
    '#description'   => t("In this mode, all JS files that are not in the whitelist are removed, and replaced with the one generated by Gulp."),
    '#default_value' => theme_get_setting('gulpifier_single_js', $theme_name),
    '#disabled'      => isset($theme_object->info['settings']['gulpifier_single_js']),
  );
  $form['gulpifier']['css']['gulpifier_js_same_group'] = array(
    '#type'          => 'checkbox',
    '#title'         => t("Enable grouping of remaining JS files"),
    '#description'   => t("All JS files that are not in the bundle are grouped for aggregation."),
    '#default_value' => theme_get_setting('gulpifier_js_same_group', $theme_name),
    '#disabled'      => isset($theme_object->info['settings']['gulpifier_js_same_group']),
  );
  $form['gulpifier']['css']['gulpifier_js_same_scope'] = array(
    '#type'          => 'checkbox',
    '#title'         => t("Move all remaining JS files in the <em>header</em> scope."),
    '#description'   => t("All JS files that are not in the header scope are moved to ease aggregation."),
    '#default_value' => theme_get_setting('gulpifier_js_same_scope', $theme_name),
    '#disabled'      => isset($theme_object->info['settings']['gulpifier_js_same_scope']),
  );

  $form['gulpifier']['css'] = array(
    '#type'  => 'fieldset',
    '#title' => t('CSS'),
  );
  $form['gulpifier']['css']['gulpifier_single_css'] = array(
    '#type'          => 'checkbox',
    '#title'         => t("Enable single CSS file (production mode)"),
    '#description'   => t("In this mode, all CSS files that are not in the whitelist are removed, and replaced with the one generated by Gulp."),
    '#default_value' => theme_get_setting('gulpifier_single_css', $theme_name),
    '#disabled'      => isset($theme_object->info['settings']['gulpifier_single_css']),
  );
  $form['gulpifier']['css']['gulpifier_css_same_group'] = array(
    '#type'          => 'checkbox',
    '#title'         => t("Enable grouping of remaining CSS files"),
    '#description'   => t("All CSS files that are not in the bundle are grouped for aggregation."),
    '#default_value' => theme_get_setting('gulpifier_css_same_group', $theme_name),
    '#disabled'      => isset($theme_object->info['settings']['gulpifier_css_same_group']),
  );
}

/**
 * Validate JSON map path
 *
 * @param $element
 * @param $form_state
 * @param $form
 */
function gulpifier_form_map_path_validate($form, &$form_state) {
  $values = $form_state['values'];
  if ($values['gulpifier_discover'] && empty($values['gulpifier_map_path'])) {
    form_set_error('gulpifier_map_path', t('The path to the JSON map is required if discovery is enabled.'));
  }
  else {
    if ($values['gulpifier_discover'] && !empty($values['gulpifier_map_path']) && !file_exists($values['gulpifier_map_path'])) {
      form_set_error('gulpifier_map_path', t('The path to the JSON map must point to a existing file.'));
    }
  }
}

/**
 * Prevent files we aren't supposed to handle from being processed.
 *
 * @param $name
 * @param $settings
 * @param array $ignore
 */
function _gulpifier_match($name, $settings, $ignore = array()) {
  if (!is_array($ignore)) {
    $ignore = array($ignore);
  }
  // Prevent some files from being processed.
  if (in_array($name, $ignore)) {
    return FALSE;
  }
  elseif ('settings' === $name) {
    return FALSE; // Ignore Drupal.settings.
  }
  elseif (FALSE !== strstr($name, 'languages/')) {
    return FALSE; // Ignore Drupal.t sources.
  }
  elseif ('external' === $settings['type']) {
    return FALSE; // Ignore external code.
  }
  elseif ('inline' === $settings['type']) {
    return FALSE; // Ignore inline code.
  }
  return TRUE;
}
