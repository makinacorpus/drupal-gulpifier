<?php

/**
 * Implements hook_form_FORM_ID_alter().
 */
function gulpifier_form_system_performance_settings_alter(&$form) {
  $front_theme = variable_get('theme_default', 'bartik');
  $theme_path = drupal_get_path('theme', $front_theme);

  $form['gulpifier'] = array(
    '#type'  => 'fieldset',
    '#title' => t("Gulpifier"),
  );
  $form['gulpifier']['gulpifier_nocachebuster'] = array(
    '#type'          => 'checkbox',
    '#title'         => t("Prevent asset cache busting"),
    '#description'   => t("In this mode, the GET parameter appended to assets (?123456789) will be removed, allowing you to edit in the broser."),
    '#default_value' => variable_get('gulpifier_nocachebuster', FALSE),
  );
  $form['gulpifier']['gulpifier_discover'] = array(
    '#type'          => 'checkbox',
    '#title'         => t("Enable JS discovery"),
    '#description'   => t("In this mode, a JSON map of the JS files used will be built upon each page request. You can manually edit it to exclude some files, or reorder the files between them."),
    '#default_value' => variable_get('gulpifier_discover', FALSE),
  );
  $form['gulpifier']['gulpifier_map_path'] = array(
    '#type'          => 'textfield',
    '#title'         => t("Path to the map.json file"),
    '#description'   => t("The path to the JSON map. It is advised to track it within your VCS, most probably in the theme."),
    '#default_value' => variable_get('gulpifier_map_path', $theme_path . '/js/'),
  );
  $form['gulpifier']['gulpifier_single_js'] = array(
    '#type'          => 'checkbox',
    '#title'         => t("Enable single JS file (production mode)"),
    '#description'   => t("In this mode, all JS files that are not in the whitelist are removed, and replaced with the one generated by Gulp."),
    '#default_value' => variable_get('gulpifier_single_js', FALSE),
  );
  $form['gulpifier']['gulpifier_single_css'] = array(
    '#type'          => 'checkbox',
    '#title'         => t("Enable single CSS file (production mode)"),
    '#description'   => t("In this mode, all CSS files that are not in the whitelist are removed, and replaced with the one generated by Gulp."),
    '#default_value' => variable_get('gulpifier_single_css', FALSE),
  );
  $form['#validate'][] = 'gulpifier_form_system_performance_settings_validate';
}

/**
 * Validate the gulpifier settings.
 *
 * @param $form
 * @param $form_state
 */
function gulpifier_form_system_performance_settings_validate(&$form, &$form_state) {
  // @TODO validate the map.json path
}

/**
 * Implements hook_js_alter().
 */
function gulpifier_js_alter(&$js) {
  global $theme;
  $front_theme = variable_get('theme_default', 'bartik');
  $theme_path = drupal_get_path('theme', $front_theme);

  // Only work on the front-end theme
  if ($theme !== $front_theme) {
    return;
  }

  // We build our whitelist, the whitelist is a list of files that won't be
  // processed by our logic.
  $whitelist = gulpifier_get_whitelist($front_theme, 'js');

  // Get the bundle script path.
  $script_path = variable_get('gulpifier_js_bundle_path', $theme_path . '/dist') . '/script.min.js';

  // First part of the proces, discover.
  if (variable_get('gulpifier_discover', FALSE)) {
    $map_path = variable_get('gulpifier_map_path', $theme_path . '/src') . '/map.json';

    gulpifier_discover_js($js, $map_path, $script_path, $whitelist);
  }

  // Force every script to be in the same scope. In that way, we could render
  // them all together anywhere we want.
  foreach ($js as $name => $settings) {
    $js[$name]['scope'] = 'header';
  }

  // A single JS file means we work in a production environment, so include only
  // our single JS file, generated by gulp, and those from the whitelist.
  if (variable_get('gulpifier_single_js', FALSE)) {
    foreach ($js as $name => $settings) {
      // Exclude all files except for our own, and Drupal.settings
      if ($name != 'settings' && $name != $script_path && !in_array($name, $whitelist, TRUE)) {
        unset($js[$name]);
      }
      else {
        // For the rest, use the same group, to have a single bundle
        $js[$name]['group'] = JS_DEFAULT;
      }
    }

    // Change its group and weight to be the first one included.
    // In that way, all other scripts whitelist don't have to take care about
    // group and weight regarding to this global aggregate scripts which may
    // contains library.
    $js[$script_path]['group'] = JS_LIBRARY;
    $js[$script_path]['preprocess'] = FALSE;
    $js[$script_path]['weight'] = -900;
  }
  else {
    // Remove our processed file on all requests.
    if (isset($js[$script_path])) {
      unset($js[$script_path]);
    }
  }
}

/**
 * Get cleaned whitelist
 *
 * @param $front_theme
 * @param $type
 *  'js' or 'css'
 * @return array
 */
function gulpifier_get_whitelist($front_theme, $type) {
  $whitelist = &drupal_static(__FUNCTION__, NULL);
  $whitelist = (array) theme_get_setting('gulpifier_whitelist', $front_theme);

  // Transform the module_name:path notation
  foreach ($whitelist as &$file) {
    if (FALSE !== strstr($file, ':')) {
      list($module, $path) = explode(':', $file, 1);
      $file = drupal_get_path('module', $module) . $path;
    }
  }

  return isset($whitelist[$type]) ? $whitelist[$type] : array();
}

/**
 * Populate a map.json with the JS files of the current page
 *
 * During discovery, we will try to populate the map.json file
 * with JS files that are included on each page of the site.
 *
 * @param $js
 *  The big JS array of the current page provided by Drupal
 * @param $map_path
 *  The JSON map file path
 * @param $script_path
 *  The minified JS file path
 * @param $whitelist
 *  The JS whitelist from the theme .info file
 */
function gulpifier_discover_js($js, $map_path, $script_path, $whitelist) {
  // Load previous list
  $contents = file_get_contents($map_path);
  $list = FALSE;
  if ($contents !== FALSE) {
    // We have a list, parse it
    $list = drupal_json_decode($contents);
  }
  // else reading file failed, and we won't update it programmatically, but
  // we will still remove our single file

  foreach ($js as $name => $settings) {
    // Prevent some files from being processed.
    if ($name == $script_path) {
      // We won't need our single file here
      unset($js[$name]);
      continue;
    }
    elseif ('settings' === $name) {
      continue; // Ignore Drupal.settings.
    }
    elseif (FALSE !== strstr($name, 'languages/')) {
      continue; // Ignore Drupal.t sources.
    }
    elseif ('external' === $settings['type']) {
      continue; // Ignore external code.
    }
    elseif ('inline' === $settings['type']) {
        continue; // Ignore inline code.
    }

    // If we have a list, update it
    if ($list !== FALSE && !in_array($name, $whitelist, TRUE)) {
      // TRUE will add it, FALSE will remove it, edit the map.json file
      // directly if you need to exclude a file
      $list[$name] = isset($list[$name]) ? $list[$name] : TRUE;
    }
  }
  // Udpate map.json
  if ($list !== FALSE && defined('JSON_PRETTY_PRINT')) {
    $json = json_encode($list, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);
    if ($contents !== $json) {
      file_put_contents($map_path, $json);
    }
  }
}

/**
 * Implements hook_css_alter().
 */
function gulpifier_css_alter(&$css) {
  global $theme;
  $front_theme = variable_get('theme_default', 'bartik');
  $theme_path = drupal_get_path('theme', $front_theme);

  // Only work on the front-end theme
  if ($theme !== $front_theme) {
    return;
  }

  // We build our whitelist, the whitelist is a list of files that won't be
  // processed by our logic.
  $whitelist = gulpifier_get_whitelist($front_theme, 'css');

  // Get the bundle style path.
  $style_path = variable_get('gulpifier_css_bundle_path', $theme_path . '/dist') . '/style.min.css';

  // alouette_single_css means we work in a production environment, so we analyse the
  // only need our single CSS file
  if (variable_get('gulpifier_single_css', FALSE)) {
    // Here we do a whitelist only on our file and inline CSS
    foreach ($css as $name => $settings) {
      if ($style_path === $name) {
        $css[$name]['preprocess'] = FALSE;
        continue; // This is our file!
      }

      if ($settings['type'] == 'inline') {
        // This will disable @import commands, better for requests
        $css[$name]['preprocess'] = FALSE;
      }
      elseif ('external' !== $settings['type'] && !in_array($name, $whitelist, TRUE)) {
        unset($css[$name]);
      }
      else {
        // For the rest, use the same group, to have a single bundle
        $css[$name]['group'] = CSS_DEFAULT;
      }
    }
  }
  else {
    // Remove our processed file on all requests.
    if (isset($css[$style_path])) {
      unset($css[$style_path]);
    }
  }
}


/**
 * Implements hook_process_html().
 */
function gulpifier_process_html(&$vars) {
  if (variable_get('gulpifier_nocachebuster', FALSE) && !stristr($_GET['q'], 'flush-cache')) {
    $vars['styles'] = preg_replace('@\.css\?.*"@U', '.css"', $vars['styles']);
    $vars['scripts'] = preg_replace('@\.js\?.*"@U', '.js"', $vars['scripts']);
  }
}
